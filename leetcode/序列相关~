
**最长递增子序列 O(NlogN)算法
felix021 @ 2009-5-13 04:15 , IT » 程序设计 , 评论(37) , 引用(0) , 阅读(53609) , Via 本站原创 大 | 中 | 小
今天回顾WOJ1398，发现了这个当时没有理解透彻的算法。
看了好久好久，现在终于想明白了。
试着把它写下来，让自己更明白。

最长递增子序列，Longest Increasing Subsequence 下面我们简记为 LIS。
排序+LCS算法 以及 DP算法就忽略了，这两个太容易理解了。

假设存在一个序列d[1..9] = 2 1 5 3 6 4 8 9 7，可以看出来它的LIS长度为5。
下面一步一步试着找出它。
我们定义一个序列B，然后令 i = 1 to 9 逐个考察这个序列。
此外，我们用一个变量Len来记录现在最长算到多少了

首先，把d[1]有序地放到B里，令B[1] = 2，就是说当只有1一个数字2的时候，长度为1的LIS的最小末尾是2。这时Len=1

然后，把d[2]有序地放到B里，令B[1] = 1，就是说长度为1的LIS的最小末尾是1，d[1]=2已经没用了，很容易理解吧。这时Len=1

接着，d[3] = 5，d[3]>B[1]，所以令B[1+1]=B[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5，很容易理解吧。这时候B[1..2] = 1, 5，Len＝2

再来，d[4] = 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] = 1, 3，Len = 2

继续，d[5] = 6，它在3后面，因为B[2] = 3, 而6在3后面，于是很容易可以推知B[3] = 6, 这时B[1..3] = 1, 3, 6，还是很容易理解吧？ Len = 3 了噢。

第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] = 4。B[1..3] = 1, 3, 4， Len继续等于3

第7个, d[7] = 8，它很大，比4大，嗯。于是B[4] = 8。Len变成4了

第8个, d[8] = 9，得到B[5] = 9，嗯。Len继续增大，到5了。

最后一个, d[9] = 7，它在B[3] = 4和B[4] = 8之间，所以我们知道，最新的B[4] =7，B[1..5] = 1, 3, 4, 7, 9，Len = 5。

于是我们知道了LIS的长度为5。

!!!!! 注意。这个1,3,4,7,9不是LIS，它只是存储的对应长度LIS的最小末尾。有了这个末尾，我们就可以一个一个地插入数据。虽然最后一个d[9] = 7更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9，那么就可以把8更新到d[5], 9更新到d[6]，得出LIS的长度为6。

然后应该发现一件事情了：在B中插入数据是有序的，而且是进行替换而不需要挪动——也就是说，我们可以使用二分查找，将每一个数字的插入时间优化到O(logN)~~~~~于是算法的时间复杂度就降低到了O(NlogN)～！

代码如下:

//在非递减序列 arr[s..e]（闭区间）上二分查找第一个大于等于key的位置，如果都小于key，就返回e+1
int upper_bound(int arr[], int s, int e, int key)
{
    int mid;
    if (arr[e] <= key)
        return e + 1;
    while (s < e)
    {
        mid = s + (e - s) / 2;
        if (arr[mid] <= key)
            s = mid + 1;
        else
            e = mid;
    }
    return s;
}

int LIS(int d[], int n)
{
    int i = 0, len = 1, *end = (int *)alloca(sizeof(int) * (n + 1));
    end[1] = d[0]; //初始化：长度为1的LIS末尾为d[0]
    for (i = 1; i < n; i++)
    {
        int pos = upper_bound(end, 1, len, d[i]); //找到插入位置
        end[pos] = d[i];
        if (len < pos) //按需要更新LIS长度
            len = pos;
    }
    return len;
}


题目来源：Leetcode
  134. Gas Station
  There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index if you can travel around the circuit once, otherwise return -1.

Note:
The solution is guaranteed to be unique. 

分析：

这道题最直观的思路，是逐个尝试每一个站点，从站 i 点出发，看看是否能走完全程。如果不行，就接着试着从站点 i+1出发。

假设从站点 i 出发，到达站点 k 之前，依然能保证油箱里油没见底儿，从k 出发后，见底儿了。那么就说明 diff[i] + diff[i+1] + ... + diff[k] < 0，而除掉diff[k]以外，从diff[i]开始的累加都是 >= 0的。也就是说diff[i] 也是 >= 0的，这个时候我们还有必要从站点 i + 1 尝试吗？仔细一想就知道：车要是从站点 i+1出发，到达站点k后，甚至还没到站点k，油箱就见底儿了，因为少加了站点 i 的油。。。

因此，当我们发现到达k 站点邮箱见底儿后，i 到 k 这些站点都不用作为出发点来试验了，肯定不满足条件，只需要从k+1站点尝试即可！因此解法时间复杂度从O(n2)降到了 O(2n)。之所以是O(2n)，是因为将k+1站作为始发站，车得绕圈开回k，来验证k+1是否满足。

等等，真的需要这样吗？

我们模拟一下过程：

a. 最开始，站点0是始发站，假设车开出站点p后，油箱空了，假设sum1 = diff[0] +diff[1] + ... + diff[p]，可知sum1 < 0；

b. 根据上面的论述，我们将p+1作为始发站，开出q站后，油箱又空了，设sum2 = diff[p+1] +diff[p+2] + ... + diff[q]，可知sum2 < 0。

c. 将q+1作为始发站，假设一直开到了未循环的最末站，油箱没见底儿，设sum3 = diff[q+1] +diff[q+2] + ... + diff[size-1]，可知sum3 >= 0。

要想知道车能否开回 q 站，其实就是在sum3 的基础上，依次加上 diff[0] 到 diff[q]，看看sum3在这个过程中是否会小于0。但是我们之前已经知道 diff[0] 到 diff[p-1] 这段路，油箱能一直保持非负，因此我们只要算算sum3 + sum1是否 <0，就知道能不能开到 p+1站了。如果能从p+1站开出，只要算算sum3 + sum1 + sum2 是否 < 0，就知都能不能开回q站了。

因为 sum1, sum2 都 < 0，因此如果 sum3 + sum1 + sum2 >=0 那么 sum3 + sum1 必然 >= 0，也就是说，只要sum3 + sum1 + sum2 >=0，车必然能开回q站。而sum3 + sum1 + sum2 其实就是 diff数组的总和 Total，遍历完所有元素已经算出来了。因此 Total 能否 >= 0，就是是否存在这样的站点的 充分必要条件。

这样时间复杂度进一步从O(2n)降到了 O(n)。

基于这个思路，可以写出更加简洁的代码：
class Solution(object):
    def canCompleteCircuit(self, gas , cost):
        if len(gas) == 0 or len(cost) == 0:
            return -1
        total = 0
        sum = 0
        start = 0
        for i in range(len(gas)):
            diff = gas[i] - cost[i]
            total += diff
            if sum < 0:
                sum = diff
                start = i
            else:
                sum += diff
        if total < 0:
            return -1
        else:
            return start

总结：

这种解法其实依托于一个数学命题：

  对于一个循环数组，如果这个数组整体和 SUM >= 0，那么必然可以在数组中找到这么一个元素：从这个数组元素出发，绕数组一圈，能保证累加和一直是处于非负状态。

我们可以通过上面的模拟过程来理解这个命题：
    diff 数组，下标从 0 到 size - 1     
    1）从下标 0 开始，以一个原则向后遍历；
    2）若子序列的和 sum 大于 0，继续扩展子序列；若子序列的和 sum 小于 0 ，这个子序列扩展过程结束；
    2）设上一个子序列扩展结束位置为p，下一个子序列从 p + 1 开始，重复 2），直到遍历到数组的尾部
我们看一下通过上述过程构造出的这些子序列，这些子序列的性质如下：
    1）这些子序列是 diff 数组的 一个划分！每一个子序列是划分的单位。
    2）对于最后一个子序列，只有一种情况，序列和 sum >= 0（因为命题的条件 数组的整体和 sum >=0）。
    3）对于每一个子序列，设数量为 count ，则从子序列的 起始元素 到 倒数第二个元素，累加和一直是出于非负状态（如果count == 1，说明这个子序列中只有一个元素，并且这个元素是 负数）；除最后一个序列外，每一个序列的最后一个元素 都小于 0。

有了上面的性质，就可以证明一些东西了：
    1）设 diff 数组 有 m 个子序列，sum(0) 代表 第一个子序列的序列和， sum(1)代表 第二个子序列的序列和，......，则 sum(0) < 0, sum(1) < 0 , sum(m-2) < 0,这可以由子序列的性质直接得来；
    2）对于最后一个序列 sum（m-1） >= 0,现在我们分析一下 >= 0 这两种情况：
	1.若 sum（m-1） > 0 ， 由于数组的整体和 大于等于 0，所以子序列的数量一定 大于等于 2.
	2.若 sum（m-1） = 0，那么子序列只有一个，从数组的起始到结尾。
    3）现在我们可以根据之前得到的结论证明 数学命题了：
	通过上述的构造子序列，我可以说，如果我想证明这个数学命题，只需证明 在 2）中的两种情况下命题成立。
	1.sum（m - 1） > 0，由 2）知，子序列不止一个；由 1）知，前 m - 1 个子序列 和 都小于 0；由命题条件知，数组整体和 大于等于 0
	  所以 sum（0） + sum （1） + ... + sum（m - 2） + sum（m-1） >= 0 ，那么 sum（0） + sum（m - 1） > 0, sum（0） + sum（1） + sum（m-1） > 0，...，sum（0） + sum （1） + ... + sum（m - 3） + sum（m-1） > 0.
  	  这样，从最后一个序列的第一个元素开始到第 m-2 个序列的最后一个元素，都能保证累加和始终为 大于 0，继续遍历到第 m-1 个子序列的最后一个元素，可以保证累加和始终 大于等于 0。
	  至此，我们找到了一个元素，从这个数组元素出发，绕数组一圈，能保证累加和一直是处于非负状态，命题成立。
	2.sum(m-1) = 0，则只有一个子序列，从子序列的起始元素开始到倒数第二个元素，累加和始终处于非负状态，加上最后一个元素 和 等于0。
	  至此，我们也找到了我们想要的开始元素----数组的起始元素，从这个数组元素出发，绕数组一圈，能保证累加和一直是处于非负状态，命题成立。
